#include <iostream>
#include <Windows.h>
#include <cstdint>
#include <vector>
#include <iomanip>
#pragma comment (lib, "crypt32")

#undef min

static unsigned char byte_7FF749A7B420[] =
{
        0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B,
        0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
};
static unsigned char byte_7FF749A7E0C0[] = {
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01,
        0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D,
        0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4,
        0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
        0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7,
        0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,
        0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,
        0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB,
        0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB,
        0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C,
        0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
        0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C,
        0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,
        0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A,
        0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3,
        0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,
        0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A,
        0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
        0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,
        0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9,
        0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9,
        0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99,
        0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};
static unsigned char byte_7FF749A7E1C0[] = {
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40,
        0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82,
        0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE,
        0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
        0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E,
        0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49,
        0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68,
        0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15,
        0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00,
        0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3,
        0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
        0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91,
        0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE,
        0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD,
        0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7,
        0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B,
        0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD,
        0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
        0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51,
        0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F,
        0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A,
        0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69,
        0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

int64_t EncryptDataBuffer(uint8_t *dataBuffer, const uint8_t *encryptionKey)
{
    __int64 result; // rax
    uint8_t v3; // [rsp+4h] [rbp-24h]
    char v4; // [rsp+4h] [rbp-24h]
    uint8_t v5; // [rsp+5h] [rbp-23h]
    uint8_t v6; // [rsp+6h] [rbp-22h]
    uint8_t v7; // [rsp+7h] [rbp-21h]
    unsigned int i; // [rsp+8h] [rbp-20h]
    unsigned int j; // [rsp+8h] [rbp-20h]
    int v10; // [rsp+Ch] [rbp-1Ch]
    int v11; // [rsp+10h] [rbp-18h]

    for ( i = 0; i < 8; ++i )
    {
        dataBuffer[4 * i] = encryptionKey[4 * i];
        dataBuffer[4 * i + 1] = encryptionKey[4 * i + 1];
        dataBuffer[4 * i + 2] = encryptionKey[4 * i + 2];
        dataBuffer[4 * i + 3] = encryptionKey[4 * i + 3];
        result = i + 1;
    }
    for ( j = 8; j < 60; ++j )
    {
        v3 = dataBuffer[4 * j - 4];
        v5 = dataBuffer[4 * j - 3];
        v6 = dataBuffer[4 * j - 2];
        v7 = dataBuffer[4 * j - 1];
        if ( !(j % 8) )
        {
            v4 = byte_7FF749A7E0C0[v5];
            v5 = byte_7FF749A7E0C0[v6];
            v6 = byte_7FF749A7E0C0[v7];
            v7 = byte_7FF749A7E0C0[dataBuffer[4 * j - 4]];
            v3 = byte_7FF749A7B420[j / 8] ^ v4;
        }
        if ( j % 8 == 4 )
        {
            v3 = byte_7FF749A7E0C0[v3];
            v5 = byte_7FF749A7E0C0[v5];
            v6 = byte_7FF749A7E0C0[v6];
            v7 = byte_7FF749A7E0C0[v7];
        }
        v11 = 4 * j;
        v10 = 4 * j - 32;
        dataBuffer[4 * j] = v3 ^ dataBuffer[v10];
        dataBuffer[v11 + 1] = v5 ^ dataBuffer[v10 + 1];
        dataBuffer[v11 + 2] = v6 ^ dataBuffer[v10 + 2];
        dataBuffer[4 * j + 3] = v7 ^ dataBuffer[v10 + 3];
        result = j + 1;
    }
    return result;
}

inline __int64 __fastcall ShiftAndXorTransform(unsigned __int8 a1)
{
    return (27 * ((a1 >> 7) & 1)) ^ (2 * a1);
}

inline int64_t XORFromIndex(uint8_t k, uint8_t* dest, const uint8_t* src)
{
    int64_t result = 0;
    for (unsigned int i = 0; i < 4; i++)
    {
        result = i;
        for (unsigned int j = 0; j < 4; j++)
        {
            dest[4 * i + j] ^= src[16 * k + 4 * i + j];
        }
    }
    return result;
}

inline void XORData(uint8_t* dest)
{
    for (uint8_t i = 0; i < 4; ++i )
    {
        uint8_t saved_first_byte = dest[4 * i];
        uint8_t total_xor = dest[4 * i + 3] ^ dest[4 * i + 2] ^ dest[4 * i + 1] ^ saved_first_byte;

        dest[4 * i] = total_xor ^ ShiftAndXorTransform(dest[4 * i + 1] ^ saved_first_byte) ^ saved_first_byte;
        dest[4 * i + 1] ^= total_xor ^ ShiftAndXorTransform(dest[4 * i + 2] ^ dest[4 * i + 1]);
        dest[4 * i + 2] ^= total_xor ^ ShiftAndXorTransform(dest[4 * i + 3] ^ dest[4 * i + 2]);
        dest[4 * i + 3] ^= total_xor ^ ShiftAndXorTransform(saved_first_byte ^ dest[4 * i + 3]);
    }
}

void EncryptSubstitution(uint8_t* dest)
{
    for ( uint8_t i = 0; i < 4; i++ ) {
        for ( uint8_t j = 0; j < 4u; j++ ) {
            dest[4 * j + i] = byte_7FF749A7E0C0[dest[4 * j + i]];
        }
    }
}

void EncryptShifts(uint8_t* dest)
{
    uint8_t v2 = dest[1];
    dest[1] = dest[5];
    dest[5] = dest[9];
    dest[9] = dest[13];
    dest[13] = v2;
    uint8_t v3 = dest[2];
    dest[2] = dest[10];
    dest[10] = v3;
    uint8_t v4 = dest[6];
    dest[6] = dest[14];
    dest[14] = v4;
    uint8_t v5 = dest[3];
    dest[3] = dest[15];
    dest[15] = dest[11];
    dest[11] = dest[7];
    dest[7] = v5;
}

void XORArrays(uint8_t* dest, const uint8_t* src)
{
    for (unsigned int i = 0; i < 16; i++)
    {
        dest[i] ^= src[i];
    }
}

int64_t EncryptBlockPart(uint8_t* dest, uint8_t* src)
{
    XORFromIndex(0, dest, src);
    for ( unsigned int i = 1; ; ++i )
    {
        EncryptSubstitution(dest);
        EncryptShifts(dest);
        if (i == 14) break;
        XORData(dest);
        XORFromIndex(i, dest, src);
    }
    return XORFromIndex(14, dest, src);
}

void EncryptBlock(uint8_t* src, uint8_t* dest, uint64_t size)
{
    constexpr auto offset = 256 - 16;

    uint8_t* prev_dest = src + offset;
    for (unsigned int i = 0; i < size; i += 16)
    {
        XORArrays(dest, prev_dest);
        EncryptBlockPart(dest, src);

        prev_dest = dest;
        dest += 16;
    }

    memcpy(src + offset, prev_dest, 16);
}

void DecryptBlockPart(uint8_t* dest, uint8_t* src);
void DecryptXORFromIndex(uint8_t k, uint8_t* dest, const uint8_t* src);

void DecryptBlock(uint8_t* src, uint8_t* dest, uint64_t size)
{
    constexpr auto offset = 256 - 16;

    std::vector<uint8_t> encrypted_prev(src + offset, src + offset + 16);
    std::vector<uint8_t> current_block(16);

    for (int64_t i = 0; i < size; i += 16)
    {
        std::copy(dest, dest + 16, current_block.begin());

        DecryptBlockPart(dest, src);

        for (unsigned int j = 0; j < 16; j++)
        {
            dest[j] ^= encrypted_prev[j];
        }

        encrypted_prev = current_block;
        dest += 16;
    }
}

void DecryptShifts(uint8_t* dest)
{
    uint8_t v5 = dest[3];
    dest[3] = dest[7];
    dest[7] = dest[11];
    dest[11] = dest[15];
    dest[15] = v5;

    uint8_t v4 = dest[2];
    dest[2] = dest[10];
    dest[10] = v4;

    uint8_t v3 = dest[6];
    dest[6] = dest[14];
    dest[14] = v3;

    uint8_t v2 = dest[1];
    dest[1] = dest[13];
    dest[13] = dest[9];
    dest[9] = dest[5];
    dest[5] = v2;
}

void DecryptXORData(uint8_t* dest)
{
    for (unsigned int i = 0; i < 3; i++)
    {
        XORData(dest);
    }
}

void DecryptSubstitution(uint8_t* dest) {
    for (unsigned int i = 0; i < 16; i++)
    {
        dest[i] = byte_7FF749A7E1C0[dest[i]];
    }
}

void DecryptBlockPart(uint8_t* dest, uint8_t* src)
{
    DecryptXORFromIndex(14, dest, src); // [+]
    for (int i = 14; i >= 1; i--)
    {
        if (i != 14) {
            DecryptXORFromIndex(i, dest, src); // [+]
            DecryptXORData(dest); // [+]
        }

        DecryptShifts(dest); // [+]
        DecryptSubstitution(dest); // [+]
    }

    DecryptXORFromIndex(0, dest, src);
}

inline void DecryptXORFromIndex(uint8_t k, uint8_t* dest, const uint8_t* src)
{
    for (unsigned int i = 0; i < 4; i++)
    {
        for (unsigned int j = 0; j < 4; j++)
        {
            dest[4 * i + j] ^= src[16 * k + 4 * i + j];
        }
    }
}


uint8_t* PrepareEncryption(uint8_t* dest, uint8_t* key, uint8_t* iv)
{
    constexpr auto offset = 256 - 16;

    EncryptDataBuffer(dest, key);
    auto result = dest;
    memcpy(dest + offset, iv, 0x10);
    return result;
}

bool EncryptSmallFile(HANDLE hFile, const wchar_t* fileName, DWORD fileSize, uint8_t alignBytes, uint8_t* encryptionKey)
{
    auto hObject = CreateFileMappingW(hFile, 0, 4, 0, fileSize, 0);
    if (!hObject) return 0;

    auto lpBaseAddress = MapViewOfFile(hObject, 6, 0, 0, 0);

    // 1. Генерируем 16 случайных байт (IV)
    // 2. Генерируем EncryptionData из этого IV и известного нам ключа шифрования
    // 3. Записываем в нулевой байт файла значение alignBytes (сколько байт было прибавлено для выравнивания по 16 байт)
    // 4. Записываем в [1:16] байты файла значение случайных байт до шифрования
    // 5. Записываем в [17:FILESIZE-17] байты файла его зашифрованное содержимое (выравнивание 16 байт)

    /*
     * Структура зашифрованного файла:
     * 1 байт: alignBytes
     * 16 байт: randomBytes
     * (fileSize-17) байт: fileContent
     */

    std::vector<uint8_t> EncryptionIV(0x10, 0x0);
    for (auto& byte : EncryptionIV)
    {
        byte = std::rand() % 0xFF;
    }

    std::vector<uint8_t> EncryptionData(0x100, 0x0);
    PrepareEncryption(EncryptionData.data(), encryptionKey, EncryptionIV.data());

    std::vector<uint8_t> FileData(fileSize, 0x0);

    // Unencrypted data
    FileData[0] = alignBytes;
    memcpy(FileData.data() + 1, EncryptionIV.data(), 0x10);

    // Encrypted data (file content)
    memcpy(FileData.data() + 17, lpBaseAddress, fileSize - 17);
    EncryptBlock(EncryptionData.data(), FileData.data() + 17, fileSize - 17);

    // Apply changes to the file
    memcpy(lpBaseAddress, FileData.data(), fileSize);

    UnmapViewOfFile(lpBaseAddress);
    CloseHandle(hObject);
    CloseHandle(hFile);

    return 1;
}

void EncodeFile(const wchar_t* name, uint8_t* key)
{
    auto hFile = CreateFileW(name, 0xC0000000, NULL, NULL, 3, 0x80, NULL);
    if (reinterpret_cast<uintptr_t>(hFile) != -1)
    {
        LARGE_INTEGER fileSize;
        auto result = GetFileSizeEx(hFile, &fileSize);
        if (result)
        {
            auto alignBytes = 16 - fileSize.QuadPart % 0x10;
            if (alignBytes == 16)
            {
                alignBytes = 0;
            }

            result = EncryptSmallFile(hFile, name, fileSize.LowPart + alignBytes + 17, alignBytes, key);
            if (!result)
            {
                std::cerr << "Unable to encrypt file" << std::endl;
                return;
            }
            std::cout << "Successfully encrypted" << std::endl;
        }
    }
}

bool DecryptSmallFile(HANDLE hFile, const wchar_t* fileName, DWORD fileSize, uint8_t* decryptionKey)
{
    auto hObject = CreateFileMappingW(hFile, nullptr, PAGE_READWRITE, 0, fileSize, nullptr);
    if (!hObject) return false;

    auto lpBaseAddress = MapViewOfFile(hObject, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (!lpBaseAddress) {
        CloseHandle(hObject);
        return false;
    }

    // Read unencrypted data
    uint8_t alignBytes = 0;
    memcpy(&alignBytes, reinterpret_cast<uint8_t*>(lpBaseAddress), 1);
    std::vector<uint8_t> EncryptionIV(0x10, 0x0);
    memcpy(EncryptionIV.data(), reinterpret_cast<uint8_t*>(lpBaseAddress) + 1, 16);

    // Read encrypted data
    std::vector<uint8_t> FileData(fileSize - 17, 0x0);
    memcpy(FileData.data(), reinterpret_cast<uint8_t*>(lpBaseAddress) + 17, FileData.size());

    // Unmap and close handles after reading the necessary data
    UnmapViewOfFile(lpBaseAddress);
    CloseHandle(hObject);
    CloseHandle(hFile);

    // Restore encrypted key
    std::vector<uint8_t> EncryptionData(0x100, 0x0);
    PrepareEncryption(EncryptionData.data(), decryptionKey, EncryptionIV.data());

    // Decode data
    std::vector<uint8_t> DecryptedData(0x100, 0x0);
    DecryptBlock(EncryptionData.data(), FileData.data(), FileData.size());

    // Reopen the file with appropriate flags for writing
    hFile = CreateFileW(fileName, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE) return false;

    // Write decrypted data back to the file
    DWORD bytesWritten = 0;
    if (!WriteFile(hFile, FileData.data(), static_cast<DWORD>(FileData.size() - alignBytes), &bytesWritten, nullptr)) {
        CloseHandle(hFile);
        return false;
    }

    // Close the file handle
    CloseHandle(hFile);

    return true;
}

void DecodeFile(const wchar_t* name, uint8_t* key)
{
    auto hFile = CreateFileW(name, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, 0x80, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        std::cerr << "Unable to open file." << std::endl;
        return;
    }

    LARGE_INTEGER fileSize;
    if (GetFileSizeEx(hFile, &fileSize))
    {
        bool result = DecryptSmallFile(hFile, name, fileSize.LowPart, key);
        if (!result)
        {
            std::cerr << "Unable to decrypt file." << std::endl;
            return;
        }
        std::cout << "Successfully decrypted." << std::endl;
    }
}


// ----------------------------
int64_t GetHash(const char *str)
{
    unsigned int v2 = 0; // [rsp+0h] [rbp-18h]

    while ( *str )
        v2 += ((v2 << 19) | ((uint64_t)v2 >> 13)) + *str++;
    return v2;
}

void decrypt(std::vector<unsigned char>& buffer)
{
    char key[16] = "Love_Her";

    const auto size = buffer.size();
    for (unsigned int i = 0; i < size; ++i)
    {
        buffer[i] -= i;
        buffer[i] ^= key[i % 8];
    }
}

int64_t GetModuleHashes(int64_t moduleHandle)
{
    unsigned int i; // [rsp+20h] [rbp-48h]
    DWORD *v4; // [rsp+28h] [rbp-40h]
    unsigned int v5; // [rsp+34h] [rbp-34h]
    int64_t v6; // [rsp+48h] [rbp-20h]
    int64_t v7; // [rsp+50h] [rbp-18h]
    int64_t v8; // [rsp+58h] [rbp-10h]

    v4 = (DWORD*)(*(unsigned int *)(moduleHandle + *(int *)(moduleHandle + 60) + 136) + moduleHandle);
    v5 = v4[6];
    v6 = moduleHandle + (unsigned int)v4[8];
    v7 = moduleHandle + (unsigned int)v4[9];
    v8 = moduleHandle + (unsigned int)v4[7];
    for ( i = 0; i < v5; ++i )
    {
        auto functionName = (const char *)(*(unsigned int *)(v6 + 4i64 * i) + moduleHandle);
        std::cout << functionName << " (0x" << std::hex << std::uppercase << (unsigned int)GetHash(functionName) << ")" << std::endl;
    }
    return 0i64;
}

void printsFunctionsHashes(const char* moduleName)
{
    HMODULE hModule = LoadLibraryA(moduleName);

    if (hModule != nullptr) {
        GetModuleHashes(reinterpret_cast<int64_t>(hModule));
    } else {
        std::cerr << "Failed to get HMODULE" << std::endl;
    }

    FreeLibrary(hModule);
}

int main() {
    std::vector<uint8_t> key = {0xDE, 0x77, 0xE3, 0x34, 0x27, 0xBE, 0xD6, 0x7D, 0x60, 0xCC,
                                0x34, 0x5D, 0xB5, 0xAF, 0xAA, 0xF2, 0xB8, 0xA4, 0xC9, 0x11,
                                0xBE, 0x0A, 0xA7, 0x0B, 0x1C, 0x64, 0x11, 0x86, 0xEC, 0x2F,
                                0xE8, 0xBB};

    //EncodeFile(L"F:\\Attachement.txt.naso", key.data());
    DecodeFile(L"F:\\Attachement.txt.naso", key.data());

    return 0;
}
